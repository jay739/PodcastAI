<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Podcast Generator</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <link href="css/styles.css" rel="stylesheet">
    <style>
        .file-drop-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s;
        }
        .file-drop-area.active {
            border-color: #4299e1;
            background-color: rgba(66, 153, 225, 0.1);
        }
        .progress-bar {
            height: 8px;
            border-radius: 4px;
            background-color: #ebf5ff;
            overflow: hidden;
        }
        .progress-bar-fill {
            height: 100%;
            background-color: #4299e1;
            transition: width 0.3s ease;
        }
        .voice-card {
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        .voice-card.selected {
            border-color: #4299e1;
            background-color: #ebf5ff;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <header class="mb-8">
            <h1 class="text-3xl font-bold text-gray-800">Podcast Generator</h1>
            <p class="text-gray-600">Upload a PDF to generate a podcast with distinctive character voices</p>
        </header>

        <main>
            <!-- Step 1: Upload PDF -->
            <section id="upload-section" class="mb-12">
                <h2 class="text-xl font-semibold mb-4">Step 1: Upload PDF Document</h2>
                <div class="file-drop-area" id="drop-area">
                    <p class="mb-4 text-gray-600">Drag & drop your PDF here, or</p>
                    <input type="file" id="file-input" accept=".pdf" class="hidden">
                    <button id="select-file-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded transition-colors">
                        Select File
                    </button>
                    <p class="mt-2 text-sm text-gray-500" id="file-info">No file selected</p>
                </div>
            </section>

            <!-- Step 2: Analysis Results (hidden initially) -->
            <section id="analysis-section" class="mb-12 hidden">
                <h2 class="text-xl font-semibold mb-4">Step 2: Document Analysis</h2>
                <div class="bg-white rounded-lg shadow p-6">
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                        <div class="p-4 bg-blue-50 rounded-lg">
                            <h3 class="font-medium text-gray-800">Pages</h3>
                            <p class="text-2xl font-bold text-blue-600" id="page-count">-</p>
                        </div>
                        <div class="p-4 bg-blue-50 rounded-lg">
                            <h3 class="font-medium text-gray-800">Words</h3>
                            <p class="text-2xl font-bold text-blue-600" id="word-count">-</p>
                        </div>
                        <div class="p-4 bg-blue-50 rounded-lg">
                            <h3 class="font-medium text-gray-800">Characters</h3>
                            <p class="text-2xl font-bold text-blue-600" id="speaker-count">-</p>
                        </div>
                    </div>

                    <h3 class="font-medium text-gray-800 mb-2">Detected Characters:</h3>
                    <div id="speakers-list" class="mb-6">
                        <p class="text-gray-600">Analyzing document...</p>
                    </div>

                    <button id="customize-voices-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded transition-colors">
                        Customize Voices
                    </button>
                </div>
            </section>

            <!-- Step 3: Voice Customization (hidden initially) -->
            <section id="voice-section" class="mb-12 hidden">
                <h2 class="text-xl font-semibold mb-4">Step 3: Customize Character Voices</h2>
                <div class="bg-white rounded-lg shadow p-6">
                    <div id="voice-customization" class="mb-6">
                        <!-- Voice cards will be added here dynamically -->
                    </div>

                    <div class="flex items-center mb-6">
                        <input type="checkbox" id="background-music" class="mr-2">
                        <label for="background-music" class="text-gray-700">Add background music</label>
                    </div>

                    <div class="flex space-x-4">
                        <button id="back-to-analysis-btn" class="border border-gray-300 text-gray-700 font-medium py-2 px-4 rounded transition-colors hover:bg-gray-100">
                            Back
                        </button>
                        <button id="generate-podcast-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded transition-colors">
                            Generate Podcast
                        </button>
                    </div>
                </div>
            </section>

            <!-- Step 4: Generation Progress (hidden initially) -->
            <section id="progress-section" class="mb-12 hidden">
                <h2 class="text-xl font-semibold mb-4">Step 4: Generating Podcast</h2>
                <div class="bg-white rounded-lg shadow p-6">
                    <p class="mb-3 text-gray-700" id="status-message">Processing...</p>
                    <div class="progress-bar mb-6">
                        <div class="progress-bar-fill" id="progress-bar" style="width: 0%"></div>
                    </div>
                    <p class="text-sm text-gray-600" id="progress-details">Starting generation...</p>
                </div>
            </section>

            <!-- Step 5: Result (hidden initially) -->
            <section id="result-section" class="mb-12 hidden">
                <h2 class="text-xl font-semibold mb-4">Step 5: Your Podcast</h2>
                <div class="bg-white rounded-lg shadow p-6">
                    <h3 class="font-medium text-gray-800 mb-4">Podcast Generation Complete!</h3>
                    
                    <div class="mb-6">
                        <audio id="audio-player" controls class="w-full">
                            Your browser does not support the audio element.
                        </audio>
                    </div>
                    
                    <div class="flex space-x-4">
                        <button id="download-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded transition-colors">
                            Download Podcast
                        </button>
                        <button id="start-over-btn" class="border border-gray-300 text-gray-700 font-medium py-2 px-4 rounded transition-colors hover:bg-gray-100">
                            Start Over
                        </button>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script>
        // Global variables to store data
        let fileId = null;
        let jobId = null;
        let speakers = [];
        let selectedFile = null;
        
        // DOM elements
        const dropArea = document.getElementById('drop-area');
        const fileInput = document.getElementById('file-input');
        const selectFileBtn = document.getElementById('select-file-btn');
        const fileInfo = document.getElementById('file-info');
        
        const uploadSection = document.getElementById('upload-section');
        const analysisSection = document.getElementById('analysis-section');
        const voiceSection = document.getElementById('voice-section');
        const progressSection = document.getElementById('progress-section');
        const resultSection = document.getElementById('result-section');
        
        const pageCount = document.getElementById('page-count');
        const wordCount = document.getElementById('word-count');
        const speakerCount = document.getElementById('speaker-count');
        const speakersList = document.getElementById('speakers-list');
        
        const customizeVoicesBtn = document.getElementById('customize-voices-btn');
        const voiceCustomization = document.getElementById('voice-customization');
        const backToAnalysisBtn = document.getElementById('back-to-analysis-btn');
        const generatePodcastBtn = document.getElementById('generate-podcast-btn');
        const backgroundMusic = document.getElementById('background-music');
        
        const statusMessage = document.getElementById('status-message');
        const progressBar = document.getElementById('progress-bar');
        const progressDetails = document.getElementById('progress-details');
        
        const audioPlayer = document.getElementById('audio-player');
        const downloadBtn = document.getElementById('download-btn');
        const startOverBtn = document.getElementById('start-over-btn');
        
        // Event Listeners
        selectFileBtn.addEventListener('click', () => {
            fileInput.click();
        });
        
        fileInput.addEventListener('change', handleFileSelect);
        
        // Drag and drop functionality
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, highlight, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, unhighlight, false);
        });
        
        function highlight() {
            dropArea.classList.add('active');
        }
        
        function unhighlight() {
            dropArea.classList.remove('active');
        }
        
        dropArea.addEventListener('drop', handleDrop, false);
        
        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        }
        
        // Button event listeners
        customizeVoicesBtn.addEventListener('click', showVoiceCustomization);
        backToAnalysisBtn.addEventListener('click', showAnalysisSection);
        generatePodcastBtn.addEventListener('click', generatePodcast);
        downloadBtn.addEventListener('click', downloadPodcast);
        startOverBtn.addEventListener('click', startOver);
        
        // File handling
        function handleFileSelect(e) {
            handleFiles(this.files);
        }
        
        function handleFiles(files) {
            if (files.length > 0) {
                const file = files[0];
                if (file.type === 'application/pdf') {
                    selectedFile = file;
                    fileInfo.textContent = `Selected: ${file.name} (${formatFileSize(file.size)})`;
                    uploadFile(file);
                } else {
                    alert('Please select a PDF file.');
                }
            }
        }
        
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' bytes';
            else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
            else return (bytes / 1048576).toFixed(1) + ' MB';
        }
        
        // API Calls
        async function uploadFile(file) {
            const formData = new FormData();
            formData.append('file', file);
            
            try {
                statusMessage.textContent = 'Uploading file...';
                showProgressSection();
                
                // In Electron, you would use IPC to communicate with main process
                // This is a placeholder for the actual implementation
                window.api.uploadPdf(file.path)
                    .then(response => {
                        fileId = response.file_id;
                        analyzeDocument();
                    })
                    .catch(error => {
                        showUploadSection();
                        alert('Error uploading file: ' + error.message);
                    });
                
                // For demonstration purposes (mock response)
                setTimeout(() => {
                    fileId = 'mock-file-id-' + Date.now();
                    analyzeDocument();
                }, 2000);
                
            } catch (error) {
                showUploadSection();
                alert('Error uploading file: ' + error.message);
            }
        }
        
        async function analyzeDocument() {
            try {
                statusMessage.textContent = 'Analyzing document...';
                progressBar.style.width = '30%';
                progressDetails.textContent = 'Extracting text and identifying characters...';
                
                // In Electron, you would use IPC to communicate with main process
                // This is a placeholder for the actual implementation
                window.api.analyzePdf(fileId)
                    .then(response => {
                        displayAnalysisResults(response);
                    })
                    .catch(error => {
                        showUploadSection();
                        alert('Error analyzing document: ' + error.message);
                    });
                
                // For demonstration purposes (mock response)
                setTimeout(() => {
                    const mockAnalysis = {
                        page_count: 42,
                        word_count: 12500,
                        speakers: [
                            { name: 'Alice', frequency: 85, source: 'dialogue_segmentation' },
                            { name: 'Bob', frequency: 64, source: 'dialogue_segmentation' },
                            { name: 'Charlie', frequency: 32, source: 'named_entity' },
                            { name: 'Narrator', frequency: 120, source: 'dialogue_segmentation' }
                        ]
                    };
                    displayAnalysisResults(mockAnalysis);
                }, 3000);
                
            } catch (error) {
                showUploadSection();
                alert('Error analyzing document: ' + error.message);
            }
        }
        
        function generatePodcast() {
            try {
                showProgressSection();
                statusMessage.textContent = 'Generating podcast...';
                progressBar.style.width = '0%';
                progressDetails.textContent = 'Starting generation process...';
                
                // Collect voice settings
                const voiceSettings = {};
                speakers.forEach(speaker => {
                    const voiceType = document.querySelector(`#voice-type-${speaker.name.replace(/\s+/g, '-')}`).value;
                    const modulationLevel = document.querySelector(`#modulation-${speaker.name.replace(/\s+/g, '-')}`).value;
                    
                    voiceSettings[speaker.name] = {
                        voice_type: voiceType,
                        modulation_level: modulationLevel
                    };
                });
                
                const requestData = {
                    file_id: fileId,
                    voice_settings: voiceSettings,
                    include_background_music: backgroundMusic.checked
                };
                
                // In Electron, you would use IPC to communicate with main process
                // This is a placeholder for the actual implementation
                window.api.generatePodcast(requestData)
                    .then(response => {
                        jobId = response.job_id;
                        checkJobStatus();
                    })
                    .catch(error => {
                        showVoiceSection();
                        alert('Error starting generation: ' + error.message);
                    });
                
                // For demonstration purposes (mock response)
                setTimeout(() => {
                    jobId = 'mock-job-id-' + Date.now();
                    checkJobStatus();
                }, 2000);
                
            } catch (error) {
                showVoiceSection();
                alert('Error starting generation: ' + error.message);
            }
        }
        
        function checkJobStatus() {
            // In Electron, you would use IPC to communicate with main process
            // This is a placeholder for the actual implementation
            window.api.jobStatus(jobId)
                .then(response => {
                    updateProgressUI(response);
                    
                    if (response.status === 'completed') {
                        showResultSection(response.result_url);
                    } else if (response.status === 'failed') {
                        showVoiceSection();
                        alert('Generation failed: ' + response.message);
                    } else {
                        // Check again after a delay
                        setTimeout(checkJobStatus, 2000);
                    }
                })
                .catch(error => {
                    showVoiceSection();
                    alert('Error checking job status: ' + error.message);
                });
            
            // For demonstration purposes (mock progress)
            simulateProgress();
        }
        
        let mockProgress = 0;
        function simulateProgress() {
            mockProgress += Math.random() * 10;
            if (mockProgress < 100) {
                const response = {
                    status: 'processing',
                    progress: mockProgress / 100,
                    message: `Generating audio for characters...`
                };
                updateProgressUI(response);
                setTimeout(simulateProgress, 1000);
            } else {
                const response = {
                    status: 'completed',
                    progress: 1.0,
                    result_url: '#mock-audio-url'
                };
                updateProgressUI(response);
                showResultSection(response.result_url);
            }
        }
        
        function downloadPodcast() {
            // In Electron, you would use IPC to save file dialog
            // This is a placeholder for the actual implementation
            window.api.downloadPodcast(jobId)
                .then(filePath => {
                    alert(`Podcast saved to: ${filePath}`);
                })
                .catch(error => {
                    alert('Error downloading podcast: ' + error.message);
                });
            
            // For demonstration purposes
            alert('In a real app, this would download the generated podcast.');
        }
        
        // UI Functions
        function displayAnalysisResults(analysis) {
            // Update UI with analysis results
            pageCount.textContent = analysis.page_count;
            wordCount.textContent = analysis.word_count;
            speakerCount.textContent = analysis.speakers.length;
            
            // Display speakers
            speakers = analysis.speakers;
            const speakersHTML = speakers.map(speaker => {
                return `<div class="py-1">
                    <span class="font-medium">${speaker.name}</span>
                    <span class="text-gray-500 text-sm ml-2">(${speaker.frequency} mentions)</span>
                </div>`;
            }).join('');
            
            speakersList.innerHTML = speakersHTML;
            
            // Show analysis section
            showAnalysisSection();
        }
        
        function showVoiceCustomization() {
            // Generate voice customization UI
            const voiceCardsHTML = speakers.map(speaker => {
                const speakerId = speaker.name.replace(/\s+/g, '-');
                return `<div class="voice-card" id="voice-card-${speakerId}">
                    <h3 class="font-medium text-gray-800 mb-2">${speaker.name}</h3>
                    
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Voice Type</label>
                        <select id="voice-type-${speakerId}" class="w-full border border-gray-300 rounded px-3 py-2">
                            <option value="neutral">Neutral</option>
                            <option value="deep">Deep</option>
                            <option value="high">High</option>
                            <option value="child" ${speaker.name.toLowerCase().includes('child') ? 'selected' : ''}>Child</option>
                            <option value="elder" ${speaker.name.toLowerCase().includes('elder') || speaker.name.toLowerCase().includes('old') ? 'selected' : ''}>Elderly</option>
                        </select>
                    </div>
                    
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Emotion Modulation</label>
                        <select id="modulation-${speakerId}" class="w-full border border-gray-300 rounded px-3 py-2">
                            <option value="low">Subtle</option>
                            <option value="medium" selected>Moderate</option>
                            <option value="high">Dramatic</option>
                        </select>
                    </div>
                </div>`;
            }).join('');
            
            voiceCustomization.innerHTML = voiceCardsHTML;
            
            showVoiceSection();
        }
        
        function updateProgressUI(response) {
            const progressPercentage = response.progress * 100;
            progressBar.style.width = `${progressPercentage}%`;
            
            if (response.status === 'processing') {
                statusMessage.textContent = 'Generating podcast...';
                progressDetails.textContent = response.message || `${Math.round(progressPercentage)}% complete`;
            } else if (response.status === 'completed') {
                statusMessage.textContent = 'Generation complete!';
                progressDetails.textContent = 'Preparing your podcast...';
                progressBar.style.width = '100%';
            }
        }
        
        function showResultSection(audioUrl) {
            // In a real app, set the audio source
            audioPlayer.src = audioUrl || '';
            
            // Show result section
            hideAllSections();
            resultSection.classList.remove('hidden');
        }
        
        function startOver() {
            // Reset all variables and UI
            fileId = null;
            jobId = null;
            speakers = [];
            selectedFile = null;
            fileInfo.textContent = 'No file selected';
            
            // Show upload section
            showUploadSection();
        }
        
        // Section visibility functions
        function hideAllSections() {
            uploadSection.classList.add('hidden');
            analysisSection.classList.add('hidden');
            voiceSection.classList.add('hidden');
            progressSection.classList.add('hidden');
            resultSection.classList.add('hidden');
        }
        
        function showUploadSection() {
            hideAllSections();
            uploadSection.classList.remove('hidden');
        }
        
        function showAnalysisSection() {
            hideAllSections();
            analysisSection.classList.remove('hidden');
        }
        
        function showVoiceSection() {
            hideAllSections();
            voiceSection.classList.remove('hidden');
        }
        
        function showProgressSection() {
            hideAllSections();
            progressSection.classList.remove('hidden');
        }
        
        // Initialize API namespace for Electron IPC communication
        // In a real app, this would be properly configured in preload.js
        window.api = {
            uploadPdf: (path) => Promise.resolve({ file_id: 'mock-id' }),
            analyzePdf: (fileId) => Promise.resolve({}),
            generatePodcast: (config) => Promise.resolve({ job_id: 'mock-job-id' }),
            jobStatus: (jobId) => Promise.resolve({ status: 'processing', progress: 0.5 }),
            downloadPodcast: (jobId) => Promise.resolve('/path/to/podcast.mp3')
        };
    </script>
</body>
</html>